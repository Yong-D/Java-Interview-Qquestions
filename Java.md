# Java内存区域

## 		线程私有

### 			虚拟机栈

​				描述的是Java方法被执行的过程，每个方法被执行过程中，都会创建一个栈帧来记录方法的局部变量表，操作数栈，动态连接,           				方法出口等。
​				随着方法的执行完毕，栈帧在栈中会有一个入栈和出栈的过程。局部变量表存放的是基本类型的数据和一些对象的引用

### 			本地方法栈

​				主要作用是调用虚拟机使用到的本地（Native） 方法

### 			程序计算器

​				是一块较小的内存空间,可以看作是当前线程执行的字节码的行号指示器。字节码解释器工作时就是通过改变这个计算器的值来				选取下一条需要执行的字节码指令。
​				如常见的：分支、循环、跳转、异常处 理、线程恢复等

## 		线程共享

### 			方法区

​				存储被虚拟机加载的类信息。常量，静态变量，代码缓存等数据。
​				运行时常量池：存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。

### 			堆

​				虚拟机中最大的一块内存，用来存放对象实例，数组等引用类型的变量

# 垃圾收集器与内存分配策略 

## 哪些内存需要回收？

### 		判断对象已死

#### 			引用计数法(基本不用)

​				在对象中添加一个计数器，有对象引用时，计数器加1.引用失效时，计算器减1。当计数器的值为0时，说明该对象不再被引用，				可以回收。 

#### 			可达性分析算法

​				如果一个对象到达GC ROOTS没有任何引用链相连接，那么就认为这个对象不可达，可以被回收。就算对象之间互有关联，但是				到GC ROOTS不可连
​				那么也认为该对象可回收。回收时查看是否有必要执行finalize()方法，假如对象没有覆盖finalize()方法，或者finalize()方法已经				被虚拟机调用 过，那么虚拟机将这两种情况都视为“没有必要执行”。
​				GC Roots：栈中的变量，参数等；方法区中的静态变量等；本地方法区中引用的对象；被同步锁所持有的对象。
​				并发的可达性分析
​				白色：没有引用指向该对象，标记为可清除
​				灰色：至少有一个引用指向该对象，该引用没有被扫描
​				黑色：已确定有多个引用指向该对象，该对象不可被回收

## 	什么时候回收？ 

​		强引用：不回收
​		软引用：内存临界值，需要扩容而无法扩容时回收
​		弱引用：任何时候都回收
​		虚引用：存在的作用时，回收对象时，给对象一个通知

## 	如何回收？

​		Minor GC：新生代
​		Major GC：老年代
​		Mixed GC：新生代和部分老年代(目前只有G1收集器支持)
​		Full GC：堆和方法区

### 	对应算法：

#### 		标记-清除

​			先标记(判断对象是否满足被回收的条件,可达性算法)出需要回收的对象，然后对标记的对象进行回收
​			效率不稳定，因为堆中有大量对象，而随着对象的增多，标记和清除的执行过程效率很低
​			空间碎片化的问题，标记清除后，会产生大量不连续的内存片段，此时如果有较大的对象产生的话，可能会由于内存不够又会触发			GC

#### 		标记-复制

​			将内存划分为相等的2块，每次使用其中的一块，使用完之后将存活的对象复制到另一块。然后再将之前的那一块全部清除
​			这样实现简单高效，但是每次内存只能用一般，内存利用率太低

#### 		标记-整理

​			先标记出存活的对象，然后让所有存活的对象移动到一边。之后清除掉边界以外的对象
​			这样移动若像老年代中有大量的对象存活的时候，会消耗大量时间去修改对象的引用，而再修改的过程中必须停掉所有的线程
​			jvm对这种操作称之为stop the world

### 	垃圾收集器

#### 		Serial收集器

​			当Serial开始工作时，要停掉全部的用户线程，待到收集结束后，用户线程才开始工作(stop the world)
​			新生代采用标记-复制算法，老年代采用标记整理算法。因为其简单而高效的特性，它被用于client模式下的新生代垃圾回收
​			Serial占用内存小，没有交叉线程

#### 		ParNew收集器

​			Serial收集器的升级版本，但他是多线程同时开始GC的。开始GC时，仍然会停掉用户线程，开启多线程GC
​			新生代采用标记-复制算法，老年代采用标记整理算法。单个存在的意义不大，甚至多线程GC模式下，还会带来多线程线程交叉的			开销。
​			它常与CMS收集器配合使用，达到并大收集的效果。ParNew收集器是激活CMS后（使用-XX：+UseConcMarkSweepGC选项）
​			的默 认新生代收集器，也可以使用-XX：+/-UseParNewGC选项来强制指定或者禁用它。

#### 		Parallel Scavenge收集器

​			是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值

#### 		Serial Old收集器

​			Serial收集器老年代版本 标记整理算法

#### 		Parallel Old收集器

​			Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。JDK6

#### 		CMS收集器

​			是一种以获取最短回收停顿时间为目标的收集器，基于标记-清除算法实现
​			1）初始标记（CMS initial mark） 
​				标记能和GC ROOTS能直接关联的对象
​			2）并发标记（CMS concurrent mark） 
​				从能和GC ROOTS直接关联的对象开始遍历对象图的过程，这是一个耗时过程，但是不需要用户线程停顿
​			3）重新标记（CMS remark） 
​				校正并发标记期间,因用户线程执行而导致标记发生变化的对象的标记记录，这个过程比初始标记的时间稍长
​			4）并发清除（CMS concurrent sweep）
​				清除掉已经被标记死亡的对象，这个过程不需要移动对象，可以和用户线程并发执行
​			对资源敏感，当处理器核数越高，垃圾回收线程越低。当核数小于4时。对用户程序影响较大，因为用户程序负载本身很高了，此			时还要分一半出来给收集器使用
​			会使应用程序变得很慢
​			容易产生浮动垃圾，即因为CMS是并发的，所以他在清理垃圾的时候，用户线程也有可能产生对象。这些对象是本次CMS无法收			集的，并且需要额外的内存来存储
​			所以JDK5时，老年代使用了68%会触发CMS,到了JDK6时设置为92%会触发。此时当内存不足时就会强制停止用户线程，Serial Old			会进行垃圾回收，所以具体设置多少值，要
​			根据实际的生产环境来设置
​			CMS是基于标记-清除算法来实现的，会产生碎片空间，当有大对象时可能会触发full GC。这时，可以调整参数使CMS整理内存空			间(移动内存)，但此时就不是并发的了

# 虚拟机性能监控、故障处理工具 







调优案例分析与实战